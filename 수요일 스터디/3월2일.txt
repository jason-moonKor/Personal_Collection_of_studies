CORS란?  -프록시 -SOP
useCallback, useMemo에 대해서.
key를 왜쓰는지?

----------------------------------------

1. CORS (Cross Origin Resource Sharing) 란?

- Origin은 URL에서 프로토콜, 도메인, 포트 번호를 합친 부분을 의미한다

https://it-eldorado.com:80/posts/123456?data=789#abc

여기서 Origin은 =>  https://it-eldorado.com:80     이부분이다

tmi) window.location.origin 는 오리진을 알수있게해주는 명령어


SOP는 한국말로 '동일 출처 정책'이라고 부르며, CORS는 '교차 출처 자원 공유'라고 부른다
SOP와 CORS는 긴밀한 관계이다.  SOP(Same Origin Policy)

SOP는 다른 Origin으로 요청을 보낼 수 없도록 금지하는 브라우저의 기본적인 보안 정책이다. 즉, 동일한 Origin으로만 요청을 보낼 수 있게 하는 것이다
그러나 기술이 발달하면서 서로 다른 Origin끼리 데이터를 주고받아야 하는 일이 많아졌고, 이로 인해 SOP는 별도의 예외 사항을 두게 되었다. 
즉, 몇 가지 예외 상황에 대해서는 다른 Origin으로도 요청을 보낼 수 있게 하는 것이다.

CORS(Cross Origin Resource Sharing)는 다른 Origin으로 요청을 보내기 위해 지켜야 하는 정책으로, 원래대로라면 SOP에 의해 막히게 될 요청을 풀어주는 정책이다.

여기서 주목할 만한 점은, CORS는 '브라우저'의 정책이라는 것이다. 즉, 서버는 평소처럼 요청이 오면 응답을 해줄 뿐이고, 
브라우저가 자신이 보낸 요청 및 서버로부터 받은 응답의 데이터가 CORS 정책을 지키는지 검사하여 안전한 요청을 보낸 건지 검사하는 것이다.
따라서 서버가 정상적으로 응답을 해줬더라도, 알고 보니 안전한 요청이 아니라고 판단되면 해당 응답을 버린다.
그렇기 때문에 서버 간 통신에서는 이러한 정책이 전혀 적용되지 않는다는 것을 알 수 있다.

다른 Origin으로의 요청을 막는 정책, 즉 SOP가 존재한다면 이러한 문제를 어느 정도 예방할 수 있다. 
해커가 구축한 웹사이트와 A 웹사이트는 당연히 Origin이 다르기 때문에, 해커의 웹사이트에서 A 웹사이트로 API 요청을 보낼 수 없기 때문이다. 
따라서 SOP는 브라우저의 아주 기본적인 보안 정책으로서 기능한다.

CORS의 동작원리
-라우저는 다른 Origin으로 요청을 보낼 때 Origin 헤더에 자신의 Origin을 설정하고, 서버로부터 응답을 받으면 응답의 Allow-Control-Allow-Origin 헤더에 
설정된 Origin의 목록에 요청의 Origin 헤더 값이 포함되는지 검사하는 것뿐이다.
즉, CORS 요청을 위해서는 서버에서 응답의 Allow-Control-Allow-Origin 헤더에 허용되는 Origin의 목록 혹은 와일드카드(*)를 설정해주면 된다. 
이것이 기본적인 CORS 정책이다. 
※ 와일드카드(*)는 모든 Origin을 허용한다는 것을 의미하는 특수 기호이다.

하지만 동작 원리를 조금 더 깊게 들어가면 CORS 요청은 다음과 같이 세 가지 유형으로 나눠서 생각해볼 수 있다.

1. 단순 요청 (Simple Request)
2. 프리플라이트 요청 (Preflight Request)
3. 3. 인증 정보를 포함한 요청 (Credentialed Request)
--------------------------------
 - useMemo, useCallback?

참고 url : https://ko.reactjs.org/docs/hooks-reference.html#usecallback

Memoization 기법
- 이미 계산 해 본 연산결과를 기억해 두었다가 동일한 계산을 시키면 다시 계산하지않고 기억해두었던 데이터를 반환시키게 하는 방법

즉, 화면에 변화가 필요없음에도 재랜더링을 하지 않게해서 성능최적화를 할수있다.


- useMemo
메모이제이션된 값을 반환합니다.

import { useMemo } from "react"      //임포트 해오고

const usememoTest = useMemo( ()=> {

	//함수동작할 내용

}, [ 배열안에내용이 바뀌어야만 useMemo함수가 실행 ] )


**중요**
useMemo로 감싼함수는 더이상 함수가 아니고 값으로 바뀜
그래서 useMemo로 만든 usememoTest 함수를 사용할땐 usememoTest(); 로 쓰면 안되고 usememoTest; 라고 써야함


- React.memo

React.memo 는 고차 컴포넌트(Higher Order Component)다.
컴포넌트가 동일한 props로 동일한 결과를 렌더링해낸다면, React.memo를 호출하고 결과를 메모이징(Memoizing)하도록 래핑하여 경우에 따라 
성능 향상을 누릴 수 있습니다. 즉, React는 컴포넌트를 렌더링하지 않고 마지막으로 렌더링된 결과를 재사용합니다.
React.memo는 props 변화에만 영향을 줍니다. React.memo로 감싸진 함수 컴포넌트 구현에 useState, useReducer 또는 useContext 훅을 사용한다면, 
여전히 state나 context가 변할 때 다시 렌더링됩니다.

*이 메서드는 오직 성능 최적화를 위하여 사용됩니다. 렌더링을 “방지”하기 위하여 사용하지 마세요. 버그를 만들 수 있습니다.

함수를 React.memo() 안에 넣어주면 됨.

하지만 객체값을 넣으면 얕은비교를 하기때문에 React.memo의 효과를 쓸수없음



-useCallback

메모이제이션된 콜백을 반환합니다.

useCallback(fn, deps)은 useMemo(() => fn, deps)와 같습니다.
-------------------

Key는 왜쓰는지?

- Key는 엘리먼트 배열을 작성할 때 반드시 포함해야 하는 특별한 문자열 Attribute입니다. Key 프로퍼티는 리액트가 변경, 추가 또는 제거된 항목을 식별하도록 돕습니다.

대부분의 경우 데이터의 ID를 키로 사용합니다. (id값을 value마다 각자 다른 값을 가지고 있을때) 없다면 index를 key로 주로 사용한다 

- 구성된 배열(또는 목록)의 순서가 변경될 수 있는 경우 Key에 index를 사용하지 않는 것이 좋습니다. 
  이로 인해 성능에 부정적인 영향을 미칠 수 있으며 컴포넌트의 State에 문제가 발생할 수 있습니다.
- 배열을 별도의 컴포넌트로 추출하는 경우 li 태그 대신 해당 컴포넌트에 Key를 적용합니다.
- 배열에 Key Attribute(속성값)가 없으면 콘솔에 경고 메시지가 표시됩니다.

tmi)
index를 안전하게 key로 사용하기 위한 조건은 무엇인가요?
- list와 items는 계산되지도 않고 변경되지도 않는 정적(static)이어야만 합니다.
- list와 items의 프로퍼티 중에 ID(유니크한 식별자)가 없어야 합니다.
- list와 items는 순서가 바뀌거나 필터링되지 않아야 합니다.

















