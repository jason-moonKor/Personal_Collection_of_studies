CORS란?  -프록시 -SOP
useCallback, useMemo에 대해서.
key를 왜쓰는지?

----------------------------------------

1. CORS (Cross Origin Resource Sharing) 란?

일단 SOP(Same Origin Policy)를 알아야 CORS를 설명가능 SOP란?
어떤 Origin(출처)에서 불러온 문서나 스크립트가 다른 Origin과 상호작용하는 것을 제한하는 중요한 보안 방식. 즉, 동일한 Origin으로만 요청을 보낼 수 있게 함
SOP(동일 출처 정책)은 잠재적으로 해로울 수 있는 정보들을 제한함으로써, 공격받을 수 있는 경로를 줄인다.
origin이란 요청을 보낸 도메인(URL에서 프로토콜,도메인,포트번호를 합친부분)을 의미하며, 같은 도메인으로 요청을 보내지 않으면 SOP(동일출처정책)에 의해 제한을 받는다.

//해커가 구축한 웹사이트와 A 웹사이트는 당연히 Origin이 다르기 때문에, 해커의 웹사이트에서 A 웹사이트로 API 요청을 보낼 수 없기 때문이다. 
//따라서 SOP는 브라우저의 아주 기본적인 보안 정책이다
 
물론 외부 API를 사용하거나 서버-클라이언트 통신 시 불편함이 존재하는데, 이를 해결하기 위해 등장한 정책중 하나가 CORS(Cross-Origin Resource Sharing) 정책입니다.
SOP는 한국말로 '동일 출처 정책'이라고 부르며, CORS는 '교차 출처 자원 공유'라고 부른다
CORS(Cross Origin Resource Sharing)는 다른 Origin으로 요청을 보내기 위해 지켜야 하는 정책으로, 원래대로라면 SOP에 의해 막히게 될 요청을 풀어주는 정책이다.




- Origin은 URL에서 프로토콜, 도메인, 포트 번호를 합친 부분을 의미한다

https://it-eldorado.com:80/posts/123456?data=789#abc

여기서 Origin은 =>  https://it-eldorado.com:80     이부분이다

tmi) window.location.origin 는 오리진을 알수있게해주는 명령어



여기서 주목할 만한 점은, CORS는 '브라우저'의 정책이라는 것이다. 즉, 서버는 평소처럼 요청이 오면 응답을 해줄 뿐이고, 
브라우저가 자신이 보낸 요청 및 서버로부터 받은 응답의 데이터가 CORS 정책을 지키는지 검사하여 안전한 요청을 보낸 건지 검사하는 것이다.
따라서 서버가 정상적으로 응답을 해줬더라도, 알고 보니 안전한 요청이 아니라고 판단되면 해당 응답을 버린다.
그렇기 때문에 서버 간 통신에서는 이러한 정책이 전혀 적용되지 않는다는 것을 알 수 있다.



CORS의 동작원리
-라우저는 다른 Origin으로 요청을 보낼 때 Origin 헤더에 자신의 Origin을 설정하고, 서버로부터 응답을 받으면 응답의 Allow-Control-Allow-Origin 헤더에 
설정된 Origin의 목록에 요청의 Origin 헤더 값이 포함되는지 검사하는 것뿐이다.
즉, CORS 요청을 위해서는 서버에서 응답의 Allow-Control-Allow-Origin 헤더에 허용되는 Origin의 목록 혹은 와일드카드(*)를 설정해주면 된다. 
이것이 기본적인 CORS 정책이다. 
※ 와일드카드(*)는 모든 Origin을 허용한다는 것을 의미하는 특수 기호이다.

하지만 동작 원리를 조금 더 깊게 들어가면 CORS 요청은 다음과 같이 세 가지 유형으로 나눠서 생각해볼 수 있다.

1. 단순 요청 (Simple Request) -> 
2. 프리플라이트 요청 (Preflight Request) -> 단순요청이 아닐경우
3. 인증 정보를 포함한 요청 (Credentialed Request) -> 

CORS를 해결하기 위한 방법?

- 프록시

컴퓨터 네트워크에서 다른 서버 상의 자원을 찾는 클라이언트로부터 요청을 받아 중계하는 서버를 말한다.
컴퓨터 네트워크에서 다른 서버로의 자원 요청을 중계하는 서버로, 분산 시스템의 구조를 단순화하고 캡슐화하여 서비스의 복잡도를 줄이는 역할을 한다. 
일반적으로 프록시는 대부분 웹 프록시를 일컫는다.

클라이언트가 필요한 서버로부터 파일, 연결, 웹 페이지 등과 같은 자원을 프록시 서버에 요청하면 프록시 서버는 클라이언트와의 사이에서 대신 통신을 수행한다. 
프록시 서버에는 클라이언트로부터 원격에 요청된 자원들이 캐시되어 임시로 저장되어 있다. 클라이언트는 자원 재요청 시 원격 서버에 접속할 필요 없이 프록시 서버 내의 
정보를 제공받을 수 있으며, 따라서 데이터 전송 시간과 외부 트래픽이 줄어들고 서버 측의 네트워크 병목 현상을 방지할 수 있다.

또한 프록시 서버 측에서 위험이 예상되는 웹 콘텐츠 및 악성코드를 필터링 함으로써 클라이언트 측의 보안을 향상시킬 수 있다. 또한 익명의 사용자가 서버에 접근하는 것을 
막고 외부 침입을 방지함으로써 방화벽 역할을 담당하기도 한다. 회사 및 중요 기관에서는 보안 유지를 위해 내부 통신과 외부 데이터 접근(특정 사이트 접근 차단)을 통제하고 
인터넷 이용률 통계를 수집하기 위해 프록시 서버를 사용하기도 한다. 반대로 사용자의 입장에서 자신의 웹 서핑 기록을 익명화하기 위해 익명 웹 프록시(anonymizer)를 
사용하기도 한다.



--------------------------------
 - useMemo, useCallback ( + React.memo )?

참고 url : https://ko.reactjs.org/docs/hooks-reference.html#usecallback

리액트는 특정 컴포넌트가 리렌더링 되면 그 컴포넌트의 모든 하위컴포넌트도 리렌더링이 된다. 
그 때 불필요하게 리렌더링 되는 상황이 발생하는데 그것을 막기 위해 JS의 메모이제이션 기능을 이용해서 만든 기능이 useMemo, useCallback + React.memo이다.

Memoization 기법
- 이미 계산 해 본 연산결과를 기억해 두었다가 동일한 계산을 시키면 다시 계산하지않고 기억해두었던 데이터를 반환시키게 하는 방법
즉, 필요없는 리랜더링을 막아 성능최적화를 할수있다.


- useMemo
메모이제이션된 값을 반환합니다.

import { useMemo } from "react"      //임포트 해오고

const usememoTest = useMemo( ()=> {

	//함수동작할 내용

}, [ 배열안에내용이 바뀌어야만 useMemo함수가 실행 ] )


**중요**
useMemo로 감싼함수는 더이상 함수가 아니고 값으로 바뀜
그래서 useMemo로 만든 usememoTest 함수를 사용할땐 usememoTest(); 로 쓰면 안되고 usememoTest; 라고 써야함


- React.memo

React.memo 는 고차 컴포넌트(Higher Order Component)다.
memo는 컴포넌트를 감싸는데 사용된다. 그 컴포넌트가 매개변수로 받는 값과 메모리에 저장된 값을 꺼내서 비교 후 만약 같다면 해당 
컴포넌트(함수)는 연산을 하지 않고 넘어간다



*이 메서드는 오직 성능 최적화를 위하여 사용됩니다. 렌더링을 “방지”하기 위하여 사용하지 마세요. 버그를 만들 수 있습니다.

함수를 React.memo() 안에 넣어주면 됨.

하지만 객체값을 넣으면 얕은비교를 하기때문에 React.memo의 효과를 쓸수없음



-useCallback

메모이제이션된 콜백을 반환합니다.

useCallback(fn, deps)은 useMemo(() => fn, deps)와 같습니다.



useCallback은 첫번째 인자로 함수를 받고 그것을 저장하여 반환한다.
useMemo는 첫번째 인자로 함수를 넣게 되는데 그 함수가 리턴한 값을 저장하고 반환한다. 

useEffect쓸때 useCallback 쓰라고 워닝뜬다

-------------------

Key는 왜쓰는지?

- Key는 엘리먼트 배열을 작성할 때 반드시 포함해야 하는 특별한 문자열 Attribute입니다. Key 프로퍼티는 리액트가 변경, 추가 또는 제거된 항목을 식별하도록 돕습니다.
가상돔과 리얼돔의 비교를 할때 필요함.

대부분의 경우 데이터의 ID를 키로 사용합니다. (id값을 value마다 각자 다른 값을 가지고 있을때) 없다면 index를 key로 주로 사용한다 

- 구성된 배열(또는 목록)의 순서가 변경될 수 있는 경우 Key에 index를 사용하지 않는 것이 좋습니다. 
  이로 인해 성능에 부정적인 영향을 미칠 수 있으며 컴포넌트의 State에 문제가 발생할 수 있습니다.
- 배열을 별도의 컴포넌트로 추출하는 경우 li 태그 대신 해당 컴포넌트에 Key를 적용합니다.
- 배열에 Key Attribute(속성값)가 없으면 콘솔에 경고 메시지가 표시됩니다.

tmi)
index를 안전하게 key로 사용하기 위한 조건은 무엇인가요?
- list와 items는 계산되지도 않고 변경되지도 않는 정적(static)이어야만 합니다.
- list와 items의 프로퍼티 중에 ID(유니크한 식별자)가 없어야 합니다.
- list와 items는 순서가 바뀌거나 필터링되지 않아야 합니다.



---------------------------

리액트 프롭스 드릴링을 해결하는법, 경험대답
리액트 라이프사이클
리액트 router의 동작방식에 대해

Props Drilling을 해결하기 위해서 어떤 시도를 했는가
React Life Cycle 순서대로
- 시간남으면 라스트 리액트 라우터의 동작방식


Context와 redux의 차이

상태관리에 대해 공부해보기!











