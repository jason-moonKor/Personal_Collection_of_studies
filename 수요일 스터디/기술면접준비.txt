- Promise가 뭔지?
프로미스는 자바스크립트 비동기 처리에 사용되는 객체입니다. 여기서 자바스크립트의 비동기 처리란 ‘특정 코드의 실행이 완료될 때까지 기다리지 않고 다음 코드를 먼저 수행하는 자바스크립트의 특성’을 의미합니다.
정해진기능을 수행하고나서 성공했다면 성공메세지를 주고
에러가있으면 에러메세지를 보여줌.

데이터를 받아오기도 전에 마치 데이터를 다 받아온 것 마냥 화면에 데이터를 표시하려고 하면 오류가 발생하거나 빈 화면이 뜹니다. 이와 같은 문제점을 해결하기 위한 방법 중 하나가 프로미스입니다.

프로미스의 3가지 상태(states)
프로미스를 사용할 때 알아야 하는 가장 기본적인 개념이 바로 프로미스의 상태(states)입니다. 여기서 말하는 상태란 프로미스의 처리 과정을 의미합니다. new Promise()로 프로미스를 생성하고 종료될 때까지 3가지 상태를 갖습니다.

Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태
Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태
Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태

Pending(대기) - new Promise() 메서드를 호출하면 대기(Pending) 상태가 됩니다.
new Promise() 메서드를 호출할 때 콜백 함수를 선언할 수 있고, 콜백 함수의 인자는 resolve, reject입니다.

Fulfilled(실행(임무수행,완료)) - 콜백 함수의 인자 resolve를 아래와 같이 실행하면 이행(Fulfilled) 상태가 됩니다.그리고 이행 상태가 되면 아래와 같이 then()을 이용하여 처리 결과 값을 받을 수 있습니다.

Rejected(실패) - new Promise()로 프로미스 객체를 생성하면 콜백 함수 인자로 resolve와 reject를 사용할 수 있다고 했습니다. 여기서 reject를 아래와 같이 호출하면 실패(Rejected) 상태가 됩니다.
그리고, 실패 상태가 되면 실패한 이유(실패 처리의 결과 값)를 catch()로 받을 수 있습니다

- 프로미스의 에러 처리 방법

1.then()의 두 번째 인자로 에러를 처리하는 방법
```
getData().then(
  handleSuccess,
  handleError
);
```

2.catch()를 이용하는 방법  => 1번보다 2번이 방법이 더 효율적이다. 가급적 2번사용
이유 : then()의 첫 번째 콜백 함수(promise가 성공했을경우의 함수) 내부에서 오류가 나는 경우 오류를 제대로 잡아내지 못합니다.
```
getData().then().catch();
```






- async await 뭔지?

Promise를 더욱 쉽게 사용할 수 있도록 ES2017(ES8) 문법으로 함수의 앞부분에 async 키워드를 추가하고, 함수 내부에서 Promise의 앞부분에 await 키워드를 사용합니다.
기존의 비동기 처리 방식인 콜백 함수와 프로미스의 단점을 보완하고 개발자가 읽기 좋은 코드를 작성할 수 있게 도와주죠.
async, await를 사용할 경우 코드가 간결해지지만, 에러처리를 잡기 위해 try catch를 사용해야합니다. 동기적인 코드흐름으로 개발이 가능합니다.
예외처리는 try catch 문을 사용한다





- async await 이 promise랑 다른점?

asnyc/await 는 비동기 코드를 작성하는 새로운 방법이다. 이전에는 비동기코드를 작성하기 위해 callback이나 promise를 사용해야 했다.
asnyc/await 는 실제로는 최상위에 위치한 promise에 대해서 사용하게 된다. Asnyc/await는 plain callback 이나 node callback과 함께 사용할 수 없다.
async/await는 promise처럼 non-blocking 이다.
async/await는 비동기 코드의 겉모습과 동작을 좀 더 동기 코드와 유사하게 만들어준다. 이것이 async/await의 가장 큰 장점이다.

왜 async/await가 Promise보다 더 나은가?

1.간결함과 깔끔함
.then 을 추가할 필요가 없었으며, response 를 해결하기 위한 비동기 함수를 만들 필요도 없었고, data 란 이름의 변수를 선언하고 사용할 필요도 없어졌다. 우리는 또한 코드의 nesting(내포화)도 피할 수 있었다

2.에러 핸들링
async/await는 동기와 비동기 에러 모두를 try/catch를 통해서 처리할 수 있게 한다.
promise를 사용한 아래 예제에서 try/catch 는 JSON.parse 가 실패하더라도 동작하지 않을 것이다. promise 안 쪽에서 발생한 에러이기 때문이다. 우리는 promise 상에서 .catch 를 호출해야하며, 에러를 처리하는 코드는 중복될 것이며 당신의 production ready 코드 안의 console.log 보다 더 복잡해질 것이다.

3.분기
가독성을 높여준다

4. 중간값(Intermediate values)
promise1 을 호출하고 여기서 return된 값을 사용해서 promise2 를 호출하고, promise3 을 호출하기 위해 두개의 promise들의 결과를 사용한다 -> 가독성을 떨어뜨리고 코드가 복잡해진다.
Promise.all 로 묶어서 nesting을 조금 피할 수 있지만 부족하다.
같은 로직을 async/await 를 사용해서 구현하면 어이없을 정도로 단순하고 직관적으로 바뀐다

5. error stack
 상용 서버에서 error log를 파악할 때에는 error가 발생했다는 것을 아는 것은 then 다음 then 다음 then에 error가 발생했다고 아는 것보다 더 유용할 것이다.

6. 디버깅

async/await를 사용하면 디버깅이 매우 쉬워진다. promise를 디버깅 할 때에는 두가지면에서 고통이 따른다.

1. return 되는 arrow function들에 breakpoint를 잡을 수 없다.

2. .then 블록 안에 breakpoint를 잡고 step-over와 같은 debug shortcuts을 사용하게되면 debugger는 .then 을 따라서 움직이지 않는다. 디버그도구가 동기화된 코드를 따라서만 움직이기 때문이다.
async/await를 사용하게되면 arrow function을 많이 사용할 필요가 없고, 디버그도구는 동기화된 코드를 실행하는 것과 다름없이 동작할 것이다.

결론
async/await는 최근 몇년간 JavaScript에 추가된 기능 중에 가장 혁명적인 기능 중에 하나이다. 이를 사용하다보면 promise가 가진 문법적인 번잡함을 대신할 직관적인 대체재라는 것을 깨닫게 될 것이다.







- 콜백함수란?

필요한 데이터를 받아와서 처리해야하는 경우, 데이터가 아니라 자꾸 undefined가 뜰 수도 있었죠. 이를 어떻게 해결했을까요? 바로 콜백(callback) 함수를 활용하는 것이었습니다

콜백 함수를 사용하면 특정 로직이 끝났을 때 원하는 동작을 실행시킬 수 있습니다. 어떤 행위가 종료되면 이어서 무언가를 하는 걸 콜백 함수라고 생각하면 쉬워요.
하지만 문제점은
callback안에 callback이 계속 이어지는 모습인 콜백지옥 패턴을 나타낼 수 있다.
콜백지옥은 가독성이 떨어진다.

이를 개선하기 위해 등장한 것이 프로미스(Promise), async/await와 같은 문법입니다.






hash, list 가 뭔지

hash : - 임의의 크기를 가진 데이터를 고정된 데이터의 크기로 변환시키는 것
 - Hash 를 사용하면 즉시 저장하거나 찾고자 하는 위치를 참조하므로 향상된 속도로 처리가 가능

List(ArrayList , Vector , LinkedList )는 입력한 모든 값들이 저장 순서보장 X 
Hash ( HashSet,LinkedHashSet , TreeSet ) 는 고유한 값만 저장. 순서보장 O 

hashset->List와 다르게 중복 값은 저장되지 X 고유한 값만 저장. 








- state, props 가 뭔지

리액트 컴포넌트에서 다루는 데이터는 두개로 나뉩니다. 바로 props 와 state 인데요, 미리 요약하여 설명드리자면 props 는 부모 컴포넌트가 자식 컴포넌트에게 주는 값입니다. 자식 컴포넌트에서는 props 를 받아오기만하고, 받아온 props 를 직접 수정 할 수 는 없습니다.

반면에 state 는 컴포넌트 내부에서 선언하며 내부에서 값을 변경 할 수 있습니다.

*defaultProps
가끔씩은 실수로 props 를 빠트려먹을때가 있습니다. 혹은, 특정 상황에 props 를 일부러 비워야 할 때도 있구요. 그러한 경우에, props 의 기본값을 설정해줄 수 있는데요, 그것이 바로 defaultProps 입니다.



호이스팅?

-var 키워드로 선언되거나 초기화된 변수, 함수선언은 현재 스코프의 최상위까지 끌어 올려집니다. 이것을 호이스팅이라고 부릅니다
함수 선언은 함수몸체가 호이스팅되는 반면, 변수 선언 형태로 작성된 함수 표현식은 변수 선언만 호이스팅됩니다.

호이스팅이 되는 이유?
선언문을 해당 스코프의 맨 위로 옮겨서 먼저 파싱하여 동작을 더 효율적이게 하기위함이다.








- 자료구조 => 스택,큐

스택?
스택은 위로만쌓을수있는 박스(후입선출(LIFO, Last-In-First-Out)) 구조
스택(stack)이란 쌓아 올린다는 것을 의미한다.
스택에서 top을 통해 삽입하는 연산을 'push' , top을 통한 삭제하는 연산을 'pop'이라고 한다.

* 스택의 활용 예시

스택의 특징인  후입선출(LIFO)을 활용하여 여러 분야에서 활용 가능하다.

웹 브라우저 방문기록 (뒤로 가기) : 가장 나중에 열린 페이지부터 다시 보여준다.
역순 문자열 만들기 : 가장 나중에 입력된 문자부터 출력한다.
실행 취소 (undo) : 가장 나중에 실행된 것부터 실행을 취소한다.
후위 표기법 계산
수식의 괄호 검사 (연산자 우선순위 표현을 위한 괄호 검사)



큐?
Queue 의 사전적 의미는 1. (무엇을 기다리는 사람, 자동차 등의) 줄 , 혹은 줄을 서서 기다리는 것을 의미한다.
큐는 가로로 빨대같은 구조(선입선출(FIFO, First in first out))

정해진 한 곳(top)을 통해서 삽입, 삭제가 이루어지는 스택과는 달리
큐는 한쪽 끝에서 삽입 작업이, 다른 쪽 끝에서 삭제 작업이 양쪽으로 이루어진다.
이때 삭제연산만 수행되는 곳을 프론트(front), 삽입연산만 이루어지는 곳을 리어(rear)로 정하여
각각의 연산작업만 수행된다. 이때, 큐의 리어에서 이루어지는 삽입연산을 인큐(enQueue)
프론트에서 이루어지는 삭제연산을 디큐(dnQueue)라고 부른다.

큐의 가장 첫 원소를 front / 가장 끝 원소를 rear
큐는 들어올 때 rear로 들어오지만 나올때는 front부터 빠지는 특성
접근방법은 가장 첫 원소와 끝 원소로만 가능
가장 먼저 들어온 프론트 원소가 가장 먼저 삭제

큐는 주로 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황에 이용한다.

우선순위가 같은 작업 예약 (프린터의 인쇄 대기열)
은행 업무
콜센터 고객 대기시간
프로세스 관리
너비 우선 탐색(BFS, Breadth-First Search) 구현
캐시(Cache) 구현







- var, let, const 이란?

var 키워드로 선언한 변수가 가진 문제점은 아래와 같습니다.
1. 변수 중복 선언 `허용`
2. 함수 레벨 스코프, `function() {}`,
3. 변수 호이스팅으로 `변수 선언문 이전에 참조가 가능`하며, 할당문 이전에 참조 시 undefined를 반환
4. `전역 변수`, `전역 함수`, 선언하지 않은 변수에 값을 할당한 `암묵적 전역`은 전역 객체 window의 프로퍼티에 할당

이런 이유로 가독성, 개발자의 의도가 흐려지게 되었고 결국 let과 const가 등장하게 됩니다.


### 📣 let
> ES6에 추가된 블록 레벨 스코프의 재할당이 가능한 키워드입니다.

let 키워드로 선언한 변수는 var 키워드를 대체할 수 있으며, 아래와 같은 특징을 갖습니다.
1. 변수 중복 선언 `금지`, 중복 선언 시 문법 에러(SyntaxError) 발생
2. `function() {}, if 문, for 문, while 문, try/catch 문 등` 함수레벨스코프이면서 블록레벨 스코프다.
3. 변수 호이스팅이 `발생하지 않는` 것처럼 동작
4. 전역 객체 window의 프로퍼티가 아니며 let 전역 변수는 `보이지 않는 개념적 블록(전역 렉시컬 환경의 선언적 환경 레코드)` 내에 존재

var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 `선언 단계`와 `초기화 단계`가 동시에 진행되는 반면 let, const 키워드로 선언한 변수는 `선언 단계`와 `초기화 단계`가 분리되어 진행됩니다.

### 📣 const
> ES6에 추가된 블록 레벨 스코프의 재할당 불가능한 상수(constant)를 선언하는 키워드입니다.

const 키워드는 기본적으로 let과 동일하게 동작합니다. 다른 점은 `반드시 선언과 동시에 초기화`해야 한다는 것이에요.






- react redux, reduce, dispatch

Redux(리덕스)란 JavaScript(자바스트립트) 상태관리 라이브러리이다.
//Redux(리덕스)의 본질은 Node.js 모듈이다. 
단방향이기때문에 예측성이 쉬워서 유지보수가 쉽다.
redux는 기본적으로 flux 패턴을 따릅니다

우리는 useState를 사용 할 경우 컴포넌트 내부에 state를 만들고, 함수로 state를 바꿉니다.
그렇기 때문에 state는 컴포넌트에 종속되는 것은 당연한 결과 입니다.
redux는 컴포넌트에 종속되지 않고, 상태관리를 컴포넌트 바깥에서 합니다.
Props 드릴링을 극복하게 해준다.
redux의 store는 프로젝트 루트레벨에 위치하고, 해당 store를 구독하는 컴포넌트는 모두 state와 state를 바꾸는 함수를 받을 수 있습니다.
어느 위치에 있든 상관 없이 단 한번에 상태를 받을 수 있게 됩니다!

redux의 데이터 흐름은 동일하게 단방향으로 view(컴포넌트)에서 Dispatch(store에서 주는 state를 바꾸는 함수)라는 함수를 동해 action(디스 패치 함수 이름)이 발동되고 reducer에 정의된 로직에 따라 store의 state가 변화하고 그 state를 쓰는 view(컴포넌트)가 변하는 흐름을 따릅니다.


reducer 란?
reducer는 store에 들어갈 state와 state를 바꿀 함수를 정의하는 곳입니다.
기본적으로 순수함수로 코딩하고, 불변성을 지켜야 합니다.

디스패치 (Dispatch) 란?
스토어의 내장 함수이며 액션을 발생시킵니다. 액션 객체를 파라미터로 받아서 호출합니다. dispatch가 호출되면 스토어의 리듀서가 실행되어 새로운 상태를 반환합니다.

스토어 (Store) 란?
리덕스를 사용하기 위해 프로젝트 내부에 단일로 생성되는 저장소입니다. 스토어에는 상태와 리듀서 및 내장 함수가 포함되어 있습니다.

구독 (Subscribe)
스토어의 내장 함수이며 action이 dispatch 될 때마다 호출됩니다. 리스너 함수를 파라미터로 받아서 호출합니다.




** 리덕스 키워드

액션 (Action)
상태에 변화가 필요할 때 발생시킴 (객체하나로 표현)
type을 필수로 그외의 값들은 개발자 마음대로 생성

액션 생성함수 (Action Creator)
컴포넌트에서 더욱 쉽게 액션을 발생시키기 위함
필수 아님

리듀서 (Reducer)
변화를 일으키는 함수
현재의 상태와 액션을 참조하여 새로운 상태를 반환

스토어 (Store)
한 애플리케이션당 하나의 스토어
현재의 앱 상태와, 리듀서, 내장함수 포함

디스패치 (dispatch)
스토어의 내장함수
액션을 발생 시키는 것

구독 (subscribe)
스토어의 내장함수
subscribe 함수에 특정 함수를 전달해주면, 액션이 디스패치 되었을 때 마다 전달해준 함수가 호출
(리액트에서는 connect 함수 또는 useSelector Hook 을 사용)




리덕스의 3가지 규칙

하나의 애플리케이션에 하나의 스토어

상태는 읽기전용
리액트의 불변성

변화를 일으키는 함수, 리듀서는 순수한 함수
동일한 인풋 => 동일한 아웃풋
new Date(), 랜덤 숫자 생성, 네트워크에 요청 등은 순수하지 않은 작업(?) -> 리듀서 밖에서 처리

- react 라이프사이클?

크게 세가지 유형으로 나눌 수 있는데 생성 될때, 업데이트 할 때, 제거할 때이다. 이를 리액트에서는 마운트, 업데이트, 언마운트라고 한다

여기서 마운트는 DOM이 생성되고 웹 브라우저 상에서 나타나는 것을 뜻하고, 반대로 언마운트는 DOM에서 제거되는 것을 뜻한다.
주의하여 볼 것은 업데이트 부분인데, 업데이트는 다음과 같은 4가지 상황에서 발생한다.

1. props가 바뀔 때
2. state가 바뀔 때
3. 부모 컴포넌트가 리렌더링 될 때
4. this.forceUpdate로 강제로 렌더링을 트리거할 때

라이프사이클은 총 9개가 존재하는데

1. constructor => 이 메서드에서는 초기 state를 정할 수 있다.
2. getDerivedStateFromProps => 이 메서드는 리액트 16.3버전 이후에 생긴 메서드이다
props로 받아 온 값을 state에 동기화시키는 용도로 사용하며, 컴포넌트가 마운트될 때와 업데이트 될 때 호출된다.
*중요 3. shouldComponentUpdate => 이 메서드는 props나 state를 변경했을 때, 리렌더링을 할지 말지 결정하는 메서드이다. 이 메서드에서는 반드시 true나 false를 반환해야한다. 이 메서드는 오직 성능 최적화만을 위한 것이며 렌더링 목적을 방지하는 목적으로 사용하게된다면 버그로 이어질 수 있다.
**중요 4. render => 이는 가장 기초적인 메서드이기도하고 가장 중요한 메서드이기도 하다. 컴포넌트를 렌더링할 때 필요한 메서드로 유일한 필수 메서드이기도 하다. 함수형 컴포넌트에서는 render를 안쓰고 컴포넌트를 렌더링할 수 있다.
5. getSnapshotBeforeUpdate => 이 메서드는 render에서 만들어진 결과가 브라우저에 실제로 반영되기 직전에 호출된다
6. componentDidMount => 이 메서드는 컴포넌트를 만들고 첫 렌더링을 마친 후 실행한다. 함수형 Hooks 에서는 useEffect를 활용하여 다음의 기능을 구현할 수 있다.
7. ComponentDidUpdate =>이것은 리렌더링을 완료한 후 실행한다. 업데이트가 끝난 직후이므로, DOM관련 처리를 해도 무방하다.
8. componentWillUnmount => 이 메서드는 컴포넌트를 DOM에서 제거할 때 실행한다. 
9. componentDidCatch





1분자기소개
왜 요리사에서 개발자로 바꿨는지
팀프로젝트 해봤는지
kosmo학원에 대해서
왜 프론트엔드를 선택했는지



보완)
Promise 관련 면접 예상질문

promise와 callback의 차이점은 무엇이고 각각 장단점은?
promise란 무엇인가
Promise.all 은 언제 쓰이는지?
async/await와 promise의 차이는?


프로미스는 기존의 콜백 패턴의 단점을 보완하고 비동기 처리 시점을 명확히 표현할 수 있다는 장점이 있어 유용하다.


promise.all은 작업들이 다 끝난이후 배열로 반환되는 반면,
promise.race 는 가장 먼저 완료된 것을 결과값으로 반환하는 함수이다.(하나라도 이행 또는 거부상태일때 완료함)

promise.all 의 경우 거부상태가 있을때 바로 반환 🚂








----------

- ssr csr 차이?

### 📣 CSR(Client-Side Rendering)
> 데이터가 없는 껍데기 HTML(그 외 정적인 파일들)만 우선 응답 받고, 데이터는 여러 정적 파일이 로드된 이후 다시 요청해서 응답 받는 방식입니다.

CSR은 SSR보다 초기 전송되는 페이지의 속도는 빠르지만 서비스에서 필요한 데이터를 클라이언트(브라우저)에서 추가로 요청하여 재구성해야 하기 때문에 전제적인 페이지 완료 시점은 SSR보다 느려집니다.

### 📣 SSR(Server-Side Rendering)
> 데이터까지 전부 삽입된 완성형 HTML을 응답 받습니다.

서버에서 사용자에게 보여줄 페이지를 모두 구성하여 사용자에게 페이지를 보여주는 방식이다. JSP/Servlet의 아키텍처에서 이 방식을 사용했는데, SSR을 사용하면 모든 데이터가 매핑된 서비스 페이지를 클라이언트(브라우저)에게 바로 보여줄 수 있습니다.

서버를 이용해서 페이지를 구성하기 때문에 클라이언트에서 구성하는 CSR(client-side rendering)보다 페이지를 구성하는 속도는 늦어지지만 전체적으로 사용자에게 보여주는 콘텐츠 구성이 완료되는 시점은 빨라진다는 장점이 있으며 SEO(search engine optimization) 또한 쉬워집니다.


### 📣 정리
CSR은 기본적으로 페이지 로드 이후 동적으로 콘텐츠를 생성하기 때문에 콘텐츠를 빠르게 소비하는 사용자의 요구 사항을 충족시킬 수가 없었습니다. 네트워크 상황이 좋지 않다면 CSR을 이용할 경우 사용자들은 글을 보기 전에 상당 시간 하얀 화면을 봐야 할 수도 있죠.

대부분 SSR을 채택하는 이유는 급변하는 프론트엔드 생태계에 대응하고, CSR의 한계를 극복하기 위해서입니다. 일반적으로 클라이언트에서 작성한 코드의 일부는 서버에서도 동일한 로직으로 구성되는 경우가 많으므로 개발의 난이도는 있지만 생산성 측면에서는 SSR을 구축하는 것이 장기적인 관점에서 더욱 효율적이게 돼죠.

또한 SSR을 사용하면 프론트엔드와 백엔드를 완전히 분리함으로써 생산성을 높일 수 있습니다. 해당 영역은 REST API를 통해 느슨하게 연결할 수 있죠.

기존 CSR 페이지는 프론트엔드에서 개발하고 SSR 페이지는 백엔드에서 개발을 했다면, SSR 환경을 구축하면 페이지의 소유권이 온전히 프론트엔드에 존재하므로 페이지가 변경될 때마다 불필요한 커뮤니케이션을 할 필요가 없어집니다.

다만, 인프라를 구축하고 운영하는 것이 부담스러운 부분이지만 요즘은 가상화를 통한 구성이 너무 잘 되어 있어서 조그만한 투자로 많은 이점을 얻을 수 있습니다.

더불어 백엔드에서도 API 개발과 데이터 활용에 더 집중할 수 있어서 서비스 품질을 높이는 데 기여할 수 있다는 장점이 있어요.

마지막으로 SSR 아키텍처를 구성하면 다른 여러 가지 대안을 활용할 수 있는 토대가 되므로 필요에 따라 CSR로만 구성할 수도, CSR과 prependering을 함께 사용하도록 개발할 수도 있습니다.






- 바벨? 웹팩?

> 바벨(Babel)이란 자바스크립트 ES6 문법을 기존의 브라우저에서도 실행할 수 있게 ES5로 변환하는 자바스크립트 트랜스 파일러입니다.

트랜스파일러는 프로그래밍 언어로 작성된 소스 코드를 읽어 동일한 수준의 다른 언어로 동등한 코드를 생성하는 도구입니다. 예를 들어 타입스크립트를 자바스크립트로 변환하고 sass를 CSS로 변환하는 것처럼 말이죠. 즉, 컴파일러는 자바나 C와 같이 낮은 추상화 단계로 언어를 변환하지만 트랜스파일러는 같은 추상화 단계에서 변환합니다.


> 웹팩(Webpack)은 오픈 소스 자바스크립트 모듈 번들러입니다.

자바스크립트를 위한 모듈 번들러이지만 호환 플러그인을 포함하는 경우 HTML, CSS, 심지어는 이미지와 같은 프론트엔드 리소스를 변환할 수 있죠. 웹팩은 의존성이 있는 모듈을 취하여 해당 모듈을 대표하는 정적 리소스를 생성합니다.

웹팩은 의존성을 취한 다음 의존성 그래프를 만듦으로써 웹 개발자들이 웹 애플리케이션 개발 목적을 위해 모듈 방식의 접근을 사용할 수 있게 도와줍니다. CLI를 통해서 사용할 수 있으며, `webpack.config.js`이라는 이름의 구성 파일을 사용하여 구성할 수 있습니다. 이 파일을 사용하면 프로젝트를 위해 로더, 플러그인 등을 정의할 수 있죠(웹팩은 로더를 통해 상당한 확장이 가능하므로 개발자들이 파일을 함께 번들링할 때 수행하기 원하는 사용자 지정 작업을 작성할 수 있어요).

단, 웹팩 설치에는 Node.js가 요구됩니다. 또한 moniker 코드 스플리팅을 사용한 코드 온 디맨드를 제공하고 있습니다.

웹팩은 다른 모듈 번들러에 비해 성능이 우수합니다. Grunt, Gulp는 오로지 리소스들에 대한 툴로 사용되며 dependency graph에 대한 개념이 없고, Browsify는 비슷한 도구이나 속도 측면에서 웹팩이 더 좋습니다.

따라서 다양한 리소스들이 들어있는 프로젝트에는 웹팩을 사용하는 것이 좋습니다.


*TMI)

### 📣 번들
> 번들(Bundle)은 소프트웨어 및 일부 하드웨어와 함께 작동하는 데 필요한 모든 것을 포함하는 Package입니다.

각 모듈들의 의존성을 파악하여 하나 또는 여러 개로 그룹핑합니다.







1. 로컬스토리지, 쿠키, 세션

- 쿠키란?

 웹사이트에 의해 유저의 컴퓨터에 놓여지는 작은 텍스트 파일들입니다. Cookies는 최대 4KB의 용량을 가진 매우 작은 양의 데이터입니다. Cookies는 사이트에서 방문한 페이지를 저장하거나 유저의 로그인 정보를 저장하는 등 다양한 방법으로 사용됩니다. 그리고 문자열만 저장할 수 있다는 제한이 있습니다.
많은 보안 웹사이트들은 로그인을 한 후 Cookies를 사용해 유저의 신원을 확인하여 모든 페이지에서 재인증을 거치지않아도 되게 됩니다. Cookies의 또 다른 용도는 사이트에서 제한된 인터넷 사용 기록을 기반으로 사용자 경험을 개선하는 것입니다.

Cookies는 두 가지 유형이 있습니다. 바로 persistent cookies와 session cookies입니다.

Seesion cookies는 만료일을 포함하지 않습니다. 대신에 브라우저나 탭이 열려있는 동안에만 저장됩니다. 브라우저가 닫히면 cookies는 영구적으로 삭제됩니다. 이 유형의 cookies는 은행 웹사이트 내에서 작업을 하고 있다가 탭을 닫으면 모든 정보를 잊어버리기 때문에 은행 유저들의 자격 증명을 저장하는데 사용될 수 있습니다.

Persistent cookies는 만료일을 가집니다. 이 cookies는 만료일까지 유저의 디스크에 저장되고 만료일이 지나면 삭제됩니다. 유저들이 방문할때마다 유저 경험을 커스텀하기 위해 특정 웹사이트에서 행동을 기록하는 등 여러 활동들에 사용될 수 있습니다.

로컬스토리지 ( Local Storage ) -

HTML5가 나온 이후, cookies의 많은 사용 방법들은 LocalStorage의 사용으로 대체되었습니다. LocalStorage는 cookies보다 더 많은 장점이 있기 때문입니다. 가장 중요한 차이점 중 하나는 cookies와는 달리모든 HTTP 요청에서 데이터를 주고받을 필요가 없다는 것입니다. HTTP 요청에서 데이터를 주고받지 않고 LocalStorage를 이용하면 클라이언트와 서버간의 전체 트래픽과 낭비되는 대역폭의 양을 줄일 수 있습니다.
데이터가 유저의 로컬 디스크에 저장되어 있으면 인터넷이 끊어져도 데이터가 삭제되거나 지워지지 않기 때문입니다.
또한 앞에서 언급했듯이 LocalStorage는 최대 5MB의 정보를 저장할 수 있습니다. 이것은 cookies가 보유할 수 있는 4KB보다 훨씬 더 많습니다.
LocalStorage의 만료 조건은 persistent cookies처럼 동작합니다. Javascript 코드를 통해 삭제하지 않으면 데이터는 자동으로 삭제되지 않습니다. 이 방식은더 오랜 시간동안 저장해야하는 큰 데이터에 유용합니다. 또한 LocalStorage를 사용하면 문자열 뿐만아니라 javascript의 primitives와 object도 저장할 수 있습니다.

결론
cookies는 더 작고 모든 HTTP 요청과함께 서버 정보를 다시 전달해주지만 LocalStorage는 더 크고 클라이언트 측에 정보를 보유할 수 있습니다.



세션 ( Session ) - 

일정 시간동안 같은 사용자(브라우저)로부터 들어오는
일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술이다.

여기서 일정 시간은 방문자가 웹 브라우저를 통해
웹 서버에 접속한 시점으로부터 웹 브라우저를 종료하여 연결을 끝내는 시점을 말한다.

즉, 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 한다.


세션 특징
웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다.
웹 서버의 저장되는 쿠키(=세션 쿠키)
브라우저를 닫거나, 서버에서 세션을 삭제했을때만 삭제가 되므로,
쿠키보다 비교적 보안이 좋다.
저장 데이터에 제한이 없다.(서버 용량이 허용하는 한...)
각 클라이언트 고유 Session ID를 부여한다.
Session ID로 클라이언트를 구분하여 각 클라이언트 요구에 맞는 서비스 제공

세션의 동작 순서
클라이언트가 페이지를 요청한다. (사용자가 웹사이트 접근)
서버는 접근한 클라이언트의 Request-Header 필드인 Cookie를 확인하여,
클라이언트가 해당 session-id를 보냈는지 확인한다.
session-id가 존재하지 않는다면,
서버는 session-id를 생성해 클라이언트에게 돌려준다.
서버에서 클라이언트로 돌려준 session-id를 쿠키를 사용해 서버에 저장한다.
쿠키 이름 : JSESSIONID
클라이언트는 재접속 시,
이 쿠키(JSESSIONID)를 이용하여 session-id 값을 서버에 전달

사용 예시
화면이 이동해도 로그인이 풀리지 않고 로그아웃하기 전까지 유지


Q. 세션을 쓰면되는데 굳이 쿠키를 사용하는 이유?

A. 세션이 쿠키에 비해 보안도 높은 편이나 쿠키를 사용하는 이유는
세션은 서버에 저장되고, 서버자원을 사용하기 때문에 사용자가 많을 경우 소모되는 자원이 상당하다.
이러한 자원관리 차원에서 쿠키와 세션을 적절한 요소 및 기능에 병행 사용하여,
서버 자원의 낭비를 방지하며 웹사이트의 속도를 높일 수 있다.


세션과 쿠키 정리 - 

1. 공통점 : 웹 통신간 유지하려는 정보(ex:로그인 정보 등)를 저장하기 위해 사용하는 것(?)
2. 차이점 : 저장위치, 저장형식, 용량제한, 만료시점 등 (해당 포스트 하단에 '표'로 정리됨)

               쿠키 : 개인 PC에 저장됨.

               세션 : 접속중인 웹 서버에 저장됨.

쿠키와 세션을 사용하는 이유

HTTP 프로토콜의 특징이자 약점을 보완하기 위해서 사용된다.

Connectionless 프로토콜 (비연결지향)

클라이언트가 서버에 요청(Request)을 했을 때,
그 요청에 맞는 응답(Response)을 보낸 후 연결을 끊는 처리방식이다.

HTTP 1.1 버전에서 연결을 유지하고, 재활용 하는 기능이 Default 로 추가되었다.
(keep-alive 값으로 변경 가능)

Stateless 프로토콜 (상태정보 유지 안함)

클라이언트의 상태 정보를 가지지 않는 서버 처리 방식이다.

클라이언트와 첫번째 통신에서 데이터를 주고 받았다 해도,
두번째 통신에서 이전 데이터를 유지하지 않는다.

서버와 클라이언트가 통신을 할 때 통신이 연속적으로 이어지지 않고 한 번 통신이 되면 끊어진다.
따라서 서버는 클라이언트가 누구인지 계속 인증을 해줘야 한다. 하지만 그것은 매우 귀찮고 번거로운 일이다. 
또한 웹페이지의 로딩을 느리게 만드는 요인이 되기도 한다. 그런 번거로움을 해결하는 방법이 바로 쿠키와 세션이다.

정리하면, 클라이언트와 정보 유지를 하기 위해 사용하는 것이 쿠키와 세션이다.









1. 클로저, 스코프

Scope(유효범위) -

프로그래밍언어에서 유효범위는 어느 범위까지 참조하는 지를 뜻한다.

유효범위의 종류에는 크게 두 가지가 있다.
전역 스코프 (Global scope) : 스크립트 전체에서 참조되는 것을 의미하며, 어느 곳에서든 참조 된다.
지역 스코프 (Local scope) : 정의된 함수 내에서만 참조되는 것을 의미하며, 밖에서는 참조 되지 않는다.
유효범위의 특징을 크게 나열하면 다음과 같다.

1. 함수 단위의 유효범위(function-level-scope)
- function-level scope란 함수 코드 블럭 내에서 선언된 변수는 함수 코드 블럭 내에서만 유효하고 함수 외부에서는 유효하지 않다는 것이다. (ES6 이후, let 키워드를 쓰면 block-level scope를 사용할 수 있다.)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8d91c22e-c4d2-438f-8832-e9336ac7a3d4/Untitled.png)
    

2.변수명 중복 허용

- 글로벌 영역에 변수를 선언하면 이 변수는 어느 곳에서든지 참조할 수 있는 global scope를 갖는 전역 변수가 된다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fdf7c388-ae37-482b-ba54-864998b4f120/Untitled.png)
    

3. 암묵적 선언(implied globals)

- 명시적으로 변수 앞에 `var` 를 붙여주지 않으면 암묵적 전역변수가 된다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/64752a9f-f603-426a-a10b-23219a17b479/Untitled.png)
    

**4. Lexical scoping (Static scoping)**

- 자바스크립트는 함수가 선언된 시점에서의 유효범위를 갖는다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d9baabc3-aa08-4cd4-a215-814dd06a9efb/Untitled.png)
    
    `printNumber`함수를 실행하기 직전에 `number`의 값을 변경 해주었으므로 `wrapper`함수를 실행 시켰을 때에 값이 변경되었다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c130b5c1-759d-47bf-9872-8ec8d9be4d0c/Untitled.png)
    
    1. var let const
    
    var 키워드로 선언한 변수가 가진 문제점은 아래와 같습니다.
    
    1. 변수 중복 선언 `허용`
    2. 함수 레벨 스코프, `function() {}`,
    3. 변수 호이스팅으로 `변수 선언문 이전에 참조가 가능`하며, 할당문 이전에 참조 시 undefined를 반환
    4. `전역 변수`, `전역 함수`, 선언하지 않은 변수에 값을 할당한 `암묵적 전역`은 전역 객체 window의 프로퍼티에 할당
    
    이런 이유로 가독성, 개발자의 의도가 흐려지게 되었고 결국 let과 const가 등장하게 됩니다.
    
    ### 📣 let
    
    > ES6에 추가된 블록 레벨 스코프의 재할당이 가능한 키워드입니다.
    > 
    
    let 키워드로 선언한 변수는 var 키워드를 대체할 수 있으며, 아래와 같은 특징을 갖습니다.
    
    1. 변수 중복 선언 `금지`, 중복 선언 시 문법 에러(SyntaxError) 발생
    2. `function() {}, if 문, for 문, while 문, try/catch 문 등` 함수레벨스코프이면서 블록레벨 스코프다.
    3. 변수 호이스팅이 `발생하지 않는` 것처럼 동작
    4. 전역 객체 window의 프로퍼티가 아니며 let 전역 변수는 `보이지 않는 개념적 블록(전역 렉시컬 환경의 선언적 환경 레코드)` 내에 존재
    
    var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 `선언 단계`와 `초기화 단계`가 동시에 진행되는 반면 let, const 키워드로 선언한 변수는 `선언 단계`와 `초기화 단계`가 분리되어 진행됩니다.
    
    ### 📣 const
    
    > ES6에 추가된 블록 레벨 스코프의 재할당 불가능한 상수(constant)를 선언하는 키워드입니다.
    > 
    
    const 키워드는 기본적으로 let과 동일하게 동작합니다. 다른 점은 `반드시 선언과 동시에 초기화`해야 한다는 것이에요.
    
    4. 캐싱처리 하는 방법
    
    **캐시란?**
    
    컴퓨터 과학에서 데이터나 값을 미리 복사해 놓는 임시 장소를 가르킵니다.
    
    ## 📌 캐싱이란?
    
    **`캐싱`**은 애플리케이션의 처리 속도를 높여 줍니다. 이미 가져온 데이터나 계산된 결과값의 복사본을 저장함으로써 처리속도를 향상시키며, 이를 통해 향후 요청을 더 빠르게 처리할 수 있습니다. 대부분의 프로그램이 동일한 데이터나 명령어에 반복해서 액세스하기 때문에 캐싱은 `효율적인 아키텍처 패턴`입니다.
    
    **웹캐시의 기본개념**
    
    웹캐시 또는 웹 캐싱이라고 불리는 이 기술들은 지연을 최소화하며 네트워크 대역에서 사용되는 패킷을 줄이기 위해 사용 된다. 일반적으로는 성능이 뛰어난 웹 캐시 서버를 구성해 반복적으로 요구하는 데이터를 캐싱 서버를 이용하도록해 속도와 네트워크 대역을 보호하는 것이다.
    
    웹캐시 서버는 주로 사용자와 웹 서버와 어플리케이션 서버 사이에 위치하며 접속이 잦은 컨텐츠를 미리 웹 캐시 서버에 저장해 두고, 일종의 미리보기와 같이 부가적인 호출 없이 데이터를 최대한 빨리 제공하는 목표를 가지고 있다.
    
    이런 웹 캐싱 기능은 서버 뿐만 아니라 각 사용자들의 브라우저에 기본적으로 탑재된 브라우저 캐싱에도 적용되도록 기능들이 개선되거나 강화되고 있는데, 이는 단순한 웹 서비스 속도 개선 작업만으로는 현재 요구되는 속도 환경에 대응하기 어렵기 때문이다.네트워크 자체가 느려서 캐시 속도가 늦어지는 경우도 있고, 일반 개인의 PC 환경에 따라 영향을 받기도한다. 그래서 웹브라우저를 넘어 웹서비스 영역 뿐만 아니라 일반 자가 접근하는 최접점인 웹브라우저 영역에서도 속도 간극을 최소화하기 위해 캐싱기술이 많이 개발되고 사용되고 있는 것이다.
    
    브라우저 캐싱은 사용자 PC에 한번 접속한 사이트에 대한 컨텐츠를 저장하는 방법이 주를 이룬다. 이렇게 특정 사이트 접속시 확인한 화면의 일부 (대부분 정적인 데이터들..)를 저장해 두고 있다가 재 방문시 저장된 데이터를 보여주는 것이다. 당연히 빠를 수밖에 없고, 네트워크가 불안한 상황에서도 일부 효과를 발휘 할 수 있다.
    
    5. 리액트를 왜쓰는지
    
    React를 사용하는 이유는 아래의 이유들 때문인거 같습니다.
    
    - Virtual DOM의 존재
    - React Native의 앱 개발 가능
    - 수 많은 커뮤니티
    - Component를 사용한 재사용이 가능하고 유지보수의 용이함
    
    ### **1. Virtual DOM의 존재**
    
    리액트의 가장 큰 특징 중 하나이기도 합니다.
    
    기존의 DOM은 페이지가 바뀔 때마다, 새 HTML를 로드하면서 DOM전체를 바꾸게 됩니다.
    
    Virtual Dom은 React 컴포넌트가 리턴하는 값에 의해 만들어져서 실제 보이고 있는 DOM과 비교해서 달라진 부분만 찾아내어 바꾸게 됩니다. 이러한 Virtual DOM 때문에 React에서 컴포넌트 단위의 개발이 가능하게 됩니다.
    
    ### **2. React Native의 앱 개발 가능**
    
    웹과 앱은 엄청난 연관이 있습니다. 웹 프로젝트가 끝나 React 하나만 잘 활용하여도
    
    React Native로 native moblie app을 만들 수 있기 때문입니다.
    
    ### **3. 수 많은 커뮤니티**
    
    개발을 하다보면 막히는 부분, 오류가 있는 부분이 생깁니다. Vue에 비해 사용자가 많고, facebook에서 만들어 계속되는 업데이트와 자료가 굉장히 방대합니다.
    
    ### **4. Component 단위 작성**
    
    **컴포넌트는 UI를 구성하는 개별적인 뷰 단위로 서로서,** UI 개발을 레고라고 한다면, 컴포넌트는 블록 역할을 하게 됩니다. 이러한 블록을 조립해 하나의 완성품을 만드는 것입니다.
    
    이러한 컴포넌트들을 나눠놨기에 다른 부분, 또 다른 웹에서 재사용이 가능해집니다. 이는 생산성과 유지 보수를 용이하게 합니다. 브라우저 화면상에 보이는 하나하나의 버튼, 탭, 아이콘 등이 모두 컴포넌트라고 보면 됩니다. 이 것들이 모여 하나의 뷰(VIEW)를 완성하게 됩니다.
    
    # TMI) Angular, Vue 와의 차이점
    
    ### **Angular**
    
    - TypeScript 기반의 오픈소스 프레임워크이다.
    - 구글의 지원
    - 양뱡향 바인딩을 지원합니다.
    - 체계적으로 잘 정리된 문서들
    - 가장 배울 것이 많고 어렵습니다.
    
    **Angular는 가볍고 빠르게 작업을 해야 하는 프로젝트보다는 큰 프로젝트에 사용하기 적합합니다. TypeScript를 기반으로 하기에 엄격하지만 그만큼 오류를 줄일 수 있습니다.**
    
    ### **Vue**
    
    - 자바스크립트의 기본 스타일을 적극적으로 적용 (학습 및 적응이 빠르다)
    - Virtaul DOM 지원
    - 양방향 바인딩
    - 빠르게 성장중인 커뮤니티
    
    React의 장점인 Virtual DOM과 Angular의 양방향 바인딩을 가져온 프레임워크이다.
    
    자바스크립의 기본 스타일을 적용하여 학습과 적응이 쉽다. 가볍고 빠르게 개발이 필요할 때 좋을 거 같습니다.
    

# 6. FLUX 구조

Flux는 MVC의 문제를 해결할 목적으로 고안한 애플리케이션 아키텍쳐입니다. Flux 애플리케이션은 디스패처(Dispatcher), 스토어(Store), 뷰(View) 등 세 부분으로 구성됩니다. 여기서 말하는 뷰는 단순히 화면에 보여지는 것을 넘어 자식 뷰로 전달도 하는 컨트롤 역할도 병행합니다. 그래서 컨트롤러 뷰 라고 불리기도 합니다.

Flux 아키텍처의 큰 특징은 단방향 데이터 흐름(unidirectional data flow)입니다. 데이터 흐름은 디스패처 => 스토어 => 뷰 로 흘러가며 뷰에서 입력되는 데이터가 발생하면 액션(Action)을 이용해 디스패처로 향하도록 합니다.

이러한 흐름의 장점은 데이터를 직접 수정할 수 없고 반드시 액션을 통해서만 수정이 일어나기 때문에 교통정리가 가능해 진다는 점입니다.

**구조와 데이터 흐름**

Flux 어플리케이션에서의 데이터는 단방향으로 흐릅니다.

[https://t1.daumcdn.net/cfile/tistory/245CD244595F2C4119](https://t1.daumcdn.net/cfile/tistory/245CD244595F2C4119)

단방향 데이터 흐름은 Flux 패턴의 핵심인데 위 다이어그램은 Flux 프로그래머를 위한 제일의 멘탈 모델이 됩니다. dispatcher, store과 view는 독립적인 노드로 입력과 출력이 완전히 구분됩니다. action은 새로운 데이터를 포함하고 있는 간단한 객체로 type 프로퍼티를 구분할 수 있습니다.

view는 사용자의 상호작용에 응답하기 위해 새로운 action을 만들어 시스템에 시스템에 전파합니다.

[https://t1.daumcdn.net/cfile/tistory/222C7A46595F2CA835](https://t1.daumcdn.net/cfile/tistory/222C7A46595F2CA835)

모든 데이터는 중앙 허브인 dispatcher를 통해 흐릅니다. action은 dispatcher에게 action creator 메소드를 제공하는데 대부분의 action은 view에서의 사용자 상호작용에서 발생합니다. dispatcher는 store를 등록하기 위한 콜백을 실행한 이후에 action을 모든 store로 전달합니다. 등록된 콜백을 활용해 store는 관리하고 있는 상태 중 어떤 액션이라도 관련이 있다면 전달해 줍니다. store는 change 이벤트를 controller-views는 이 이벤트를 듣고 있다가 이벤트 핸들러가 있는 store에서 데이터를 다시 가져옵니다. controller-views는 스스로의 setState() 메소드를 호출하고 컴포넌트 트리에 속해 있는 자식 노드 모두를 다시 렌더링하게 됩니다.

- **액션 생성자(Action creator)**
    - 액션이란 어떤 행위인지와 그 행위로부터 넘겨받은 값들을 가진 하나의 객체를 말한다. 따라서 어떤 액션인지를 가리키는 `type` 과 넘겨받은 값인 `payload` 를 가진다. 액션 생성자는 기존 상태를 변경하기 위한 액션의 생성을 담당하며 해당 액션을 생성해서 디스패쳐에 넘겨준다.
- **디스패쳐(Dispatcher)**
    - 디스패쳐는 모든 액션들을 받아서 의존성을 적절히 처리해준 다음 모든 스토어에게 넘긴다. 여기서 중요한 점은 모든 스토어가 모든 액션을 받는다는 것이다.
- **스토어(Store)**
    - 스토어는 모든 액션을 받아서 자신에게 적합한 액션이 어떤 건지 필터링한다. 이후 상태값을 변경하고 자신에게 연결된 컨트롤러 뷰에게 상태가 변화되었음을 알린다.
- **컨트롤러 뷰(Controller View)와 뷰(View)**
    - 여기서 컨트롤러 뷰는 전체적으로 화면에 나타는 자식 뷰들과 스토어를 연결하는 매개체이다. 자식 뷰들은 컨트롤러 뷰에게 변화된 상태를 받고 그 상태에 따라 다시 렌더링이 된다.
    

## 상태관리에 대해 요약 및 정리

프로젝트의 크기가 크지 않고 상태값이 많지 않다면 Context API와 useReducer와 같은 리액트의 기능을 조합해서 사용할 수도 있을 것이다. 

하지만 프로젝트의 크기가 점점 커지고 그 복잡성이 기하급수적으로 늘어나게 될 것 같다면 Redux를 사용해서 상태관리를 하는 것이 프로젝트 관리에 훨씬 용이할 것이다.

## 7. 브라우저 렌더링 과정

1. HTML 파일과 CSS 파일을 파싱해서 각각 Tree를 만든다. (Parsing)
2. 두 Tree를 결합하여 Rendering Tree를 만든다. (Style)
3. Rendering Tree에서 각 노드의 위치와 크기를 계산한다. (Layout)
4. 계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고, 레이어를 만든다. (Paint)
5. 레이어를 합성하여 실제 화면에 나타낸다. (Composite)

### **Parsing**

브라우저가 페이지를 렌더링하려면 가장 먼저 받아온 HTML 파일을 해석해야한다. Parsing 단계는 HTML 파일을 해석하여 DOM(Document Object Model) Tree를 구성하는 단계이다.

파싱 중 HTML에 CSS가 포함되어 있다면 CSSOM(CSS Object Model) Tree 구성 작업도 함께 진행한다.

![https://tecoble.techcourse.co.kr/static/1d5973bb2abd4ea8580e2d6f9f286640/1805d/2021-10-24-browser-rendering-1.png](https://tecoble.techcourse.co.kr/static/1d5973bb2abd4ea8580e2d6f9f286640/1805d/2021-10-24-browser-rendering-1.png)

### **Style**

Style 단계에서는 Parsing 단계에서 생성된 DOM Tree와 CSSOM Tree를 매칭시켜서 Render Tree를 구성한다. Render Tree는 실제로 화면에 그려질 Tree이다.

예를 들면 Render Tree를 구성할때 `visibility: hidden`은 요소가 공간을 차지하고, 보이지만 않기 때문에 Render Tree에 포함이 되지만, `display: none` 의 경우 Render Tree에서 제외된다.

![https://tecoble.techcourse.co.kr/static/812332bcab15fdc8d05543579dad9f5c/919e0/2021-10-24-browser-rendering-2.png](https://tecoble.techcourse.co.kr/static/812332bcab15fdc8d05543579dad9f5c/919e0/2021-10-24-browser-rendering-2.png)

### **Layout**

Layout 단계에서는 Render Tree를 화면에 어떻게 배치해야 할 것인지 노드의 정확한 위치와 크기를 계산한다.

루트부터 노드를 순회하면서 노드의 정확한 크기와 위치를 계산하고 Render Tree에 반영한다. 만약 크기 값을 %로 지정하였다면, Layout 단계에서 % 값을 계산해서 픽셀 단위로 변환한다.

### **Paint**

Paint 단계에서는 Layout 단계에서 계산된 값을 이용해 Render Tree의 각 노드를 화면상의 실제 픽셀로 변환한다. 이때 픽셀로 변환된 결과는 하나의 레이어가 아니라 여러 개의 레이어로 관리된다.

당연한 말이지만 스타일이 복잡할수록 Paint 시간도 늘어난다. 예를 들어, 단색 배경의 경우 시간과 작업이 적게 필요하지만, 그림자 효과는 시간과 작업이 더 많이 필요하다.

### **Composite**

Composite 단계에서는 Paint 단계에서 생성된 레이어를 합성하여 실제 화면에 나타낸다. 우리는 화면에서 웹 페이지를 볼 수 있다.

### 렌더링 최적화 - Reflow, Repaint 줄이기

---

지금까지 웹 페이지가 렌더링되는 과정을 알아보았습니다. 그렇다면 웹 성능 최적화를 어떻게 할 수 있을까요? 이를 알려면 Reflow와 Repaint에 대해 먼저 짚고 넘어가야 합니다.

**Reflow (Layout)**

위에서 언급된 렌더링 과정을 거친 뒤에 최종적으로 페이지가 그려진다고 해서 렌더링 과정이 다 끝난것이 아닙니다. 어떠한 액션이나 이벤트에 따라 html 요소의 크기나 위치등 레이아웃 수치를 수정하면 그에 영향을 받는 자식 노드나 부모 노드들을 포함하여 Layout 과정을 다시 수행하게 됩니다. 이렇게 되면 Render Tree와 각 요소들의 크기와 위치를 다시 계산하게 됩니다. 이러한 과정을 Reflow라고 합니다.

```
// reflow 발생 예제
function reflow() {
	document.getElementById('content').style.width = '600px';
}
```

Reflow가 일어나는 대표적인 경우는 아래와 같습니다.

- 페이지 초기 렌더링 시(최초 Layout 과정)
- 윈도우 리사이징 시 (Viewport 크기 변경시)
- 노드 추가 또는 제거
- 요소의 위치, 크기 변경 (left, top, margin, padding, border, width, height, 등..)
- 폰트 변경 과(텍스트 내용) 이미지 크기 변경(크기가 다른 이미지로 변경 시)
- 

**Repaint (Paint)**

Reflow만 수행되면 실제 화면에 반영되지 않습니다. 위에서 언급된 렌더링 과정과 같이 Render Tree를 다시 화면에 그려주는 과정이 필요합니다. 결국은 Paint 단계가 다시 수행되는 것이며 이를 Repaint 라고 합니다.

하지만 무조건 Reflow가 일어나야 Repaint가 일어나는것은 아닙니다. background-color, visibility와 같이 레이아웃에는 영향을 주지 않는 스타일 속성이 변경되었을 때는 Reflow를 수행할 필요가 없기 때문에 Repaint만 수행하게 됩니다.

## 8. 크로스브라우징

### 크로스 브라우징 이란?

웹 페이지 제작 시에 모든 브라우저에서 깨지지 않고 의도한 대로 올바르게(호환성) 나오게 하는 작업을 말한다.[HTML, CSS, Javascript 작성 시 W3C의 웹 규격에 맞는 코딩을 함으로써 어느 브라우저, 기기에서 사이트가 의도된 대로 보여지고 작동되는 기법.]

### 크로스 브라우징 작업이 필요한 원인은 무엇일까?

**브라우저 마다 랜더링 엔진**이 다르기 때문이다.

- 작동되지 않는 HTML5, Javascript 코드가 존재
- 해석하지 못하는 CSS 코드 존재
- 브라우저 버그들이 존재
- 브라우저마다 자체적인 CSS 스타일

## 9. 이벤트 버블링과 캡춰링

# [버블링](https://ko.javascript.info/bubbling-and-capturing#ref-5142)

버블링(bubbling)의 원리는 간단합니다.

**한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작합니다.**

개의 요소가 `FORM > DIV > P` 형태로 중첩된 구조를 살펴봅시다. 요소 각각에 핸들러가 할당되어 있습니다.

`<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>`

  `</div>`

`</form>`

가장 안쪽의 `<p>`를 클릭하면 순서대로 다음과 같은 일이 벌어집니다.

1. `<p>`에 할당된 `onclick` 핸들러가 동작합니다.
2. 바깥의 `<div>`에 할당된 핸들러가 동작합니다.
3. 그 바깥의 `<form>`에 할당된 핸들러가 동작합니다.
4. `document` 객체를 만날 때까지, 각 요소에 할당된 `onclick` 핸들러가 동작합니다.

이런 동작 방식 때문에 `<p>` 요소를 클릭하면 `p` → `div` → `form` 순서로 3개의 얼럿 창이 뜨는것이죠.

이런 흐름을 '이벤트 버블링’이라고 부릅니다. 이벤트가 제일 깊은 곳에 있는 요소에서 시작해 부모 요소를 거슬러 올라가며 발생하는 모양이 마치 물속 거품(bubble)과 닮았기 때문입니다.

### 버블링 막는방법

<body onclick="alert(`버블링은 여기까지 도달하지 못합니다.`)">
<button onclick="event.stopPropagation()">클릭해 주세요.</button>
</body>

한 요소의 특정 이벤트를 처리하는 핸들러가 여러개인 상황에서, 핸들러 중 하나가 버블링을 멈추더라도 나머지 핸들러는 여전히 동작합니다.

`event.stopPropagation()`은 위쪽으로 일어나는 버블링은 막아주지만, 다른 핸들러들이 동작하는 건 막지 못합니다.

버블링을 멈추고, 요소에 할당된 다른 핸들러의 동작도 막으려면 `event.stopImmediatePropagation()`을 사용해야 합니다. 이 메서드를 사용하면 요소에 할당된 특정 이벤트를 처리하는 핸들러 모두가 동작하지 않습니다.

**꼭 필요한 경우를 제외하곤 버블링을 막지 마세요!**

버블링은 유용합니다. 버블링을 꼭 멈춰야 하는 명백한 상황이 아니라면 버블링을 막지 마세요. 아키텍처를 잘 고려해 진짜 막아야 하는 상황에서만 버블링을 막으세요.

`event.stopPropagation()`은 추후에 문제가 될 수 있는 상황을 만들어낼 수 있습니다.

이벤트 버블링을 막아야 하는 경우는 거의 없습니다. 버블링을 막아야 해결되는 문제라면 커스텀 이벤트 등을 사용해 문제를 해결할 수 있습니다. 커스텀 이벤트 사용 방법은 추후에 다루겠습니다. 핸들러의 `event` 객체에 데이터를 저장해 다른 핸들러에서 읽을 수 있게 하면, 아래쪽에서 무슨 일이 일어나는지를 부모 요소의 핸들러에게 전달할 수 있으므로, 이 방법으로도 이벤트 버블링을 통제할 수 있습니다.

# [캡처링](https://ko.javascript.info/bubbling-and-capturing#ref-5145)

이벤트엔 버블링 이외에도 ‘캡처링(capturing)’ 이라는 흐름이 존재합니다. 실제 코드에서 자주 쓰이진 않지만, 종종 유용한 경우가 있으므로 알아봅시다.

표준 [DOM 이벤트](http://www.w3.org/TR/DOM-Level-3-Events/)에서 정의한 이벤트 흐름엔 3가지 단계가 있습니다.

1. 캡처링 단계 – 이벤트가 하위 요소로 전파되는 단계
2. 타깃 단계 – 이벤트가 실제 타깃 요소에 전달되는 단계
3. 버블링 단계 – 이벤트가 상위 요소로 전파되는 단계

**캡처링 단계를 이용해야 하는 경우는 흔치 않기 때문에, 이전까진 주로 버블링만 설명했습니다. 캡처링에 관한 코드를 발견하는 일은 거의 없을 겁니다.**

## 9. 이벤트 바인딩, 이벤드 핸들링

# **Event Binding**

---

바인딩이란, 서로 묶어서 연결해 준다는 뜻이다. 이벤트 바인딩이란, 발생하는 이벤트와 그 후에 어떤 일이 벌어질지 알려주는 함수(콜백함수)와 묶어서 연결해 준다는 뜻이다. 예를 들어, 어떤 버튼을 사용자가 클릭하게 되면, 클릭(‘click’)이벤트가 발생하게 되고, 그 이벤트가 발생했을 때 어떤 일이 벌어진다는 것을 알려주는 콜백함수를 실행하게 된다. 이때, 이 콜백함수를 이벤트 핸들러라고 한다.

이벤트 바인딩에는 대표적으로 3가지 방식이 있다.

1. HTML 이벤트 핸들러
2. 전통적인 DOM 이벤트 핸들러
3. Event Listener를 이용한 이벤트 핸들러

1~2번의 단점을 보완한 방식이 Event Listener를 이용한 이벤트 핸들러 방식이다.

****Event Listener를 이용한 이벤트 핸들러****

addEventListener 함수를 이용하여 대상 요소(Event Target)에 이벤트를 바인딩하고, 해당 이벤트가 발생했을 때 실행될 콜백 함수를 지정한다.

```
target.addEventListener(type, listener[, useCapture]);

var el = document.getElementById("outside");
el.addEventListener("click", function(){modifyText("four")}, false);

```

addEventListener 함수의 인수:

- type: 이벤트 타입
- listener: 이벤트 핸들러, 즉 이벤트가 발생했을 때, 실행될 콜백함수
- useCapture: true면 Capturing, false면 Bubbling(Default: false)

Event Listener를 이용한 이벤트 핸들러의 장점

- 하나의 이벤트에 대해 하나 이상의 핸들러를 추가할 수 있다.
- 캡처링(Capturing)과 버블링(Bubbling)을 지원한다.
- HTML 요소뿐만아니라 모든 DOM 요소에 대해 동작한다.

```
<label for='email'>Your Email</label>
<input type='text' id='email'>

var elem = document.getElementById('email');
elem.addEventListener('blur', function() {
  alert('Your Email!');
});

```

참고로, addEventListener 함수는 IE 9 이상에서 동작한다. IE 8 이하에서는 attachEvent 함수를 사용한다.

만약 addEventListener 함수 앞에 대상요소(elem)를 지정하지 않으면, blur 이벤트는 전역객체 window에 바인딩된다.

## **`display:none` vs `visibility : hidden` 차이**

`display:none`와 `visibility : hidden`은 둘 다 요소를 보이지 않게 하는 속성이라는 점에서 같지만, UI적으로 볼 때 둘은 완전히 다릅니다. `display:none`
은 화면 상 어떤 영역을 차지하지 않고 완전히 삭제된 것처럼 보이게 합니다. 그러나 `visibility:hidden`은 해당 요소가 보이지 않을 뿐 요소가 존재하는 영역은 확실히 보이게 됩니다.

## 시멘틱 태그란?

일반적으로 HTML5로 넘어오면서 태그의 가장 큰 변화는 시멘틱 태그라고 말하는데요. 그리고 이 때문에 일반적으로 HTML5 웹 페이지를 시멘틱 웹페이지라고 말합니다. . 

일단 시멘틱(Semantic)은 '**의미론적인'**이라는 영어 단어입니다.

[https://t1.daumcdn.net/cfile/tistory/261CDE33564B2D3D2E](https://t1.daumcdn.net/cfile/tistory/261CDE33564B2D3D2E)

**시멘틱태그의 기본적인 구성**

현대에는 이와같은 웹페이지가 구성됩니다. 이구조를 다른 웹사이트를 보아도 대부분의 사이트가 이런구성으로 이루어져 있습니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ad4d2d31-1080-4334-accf-24685a65176d/Untitled.png)

## 동기 & 비동기란?

### 동기 - 블로킹 방식이다

블록킹의 경우 직접 제어할 수 없는 대상의 작업이 끝날 때까지 제어권을 넘겨주지 않는 것이다. 작업이 순차적으로 진행되는 것이 보장되고, 블록킹 방식이기 때문에 어떠한 작업이 진행 중일 때는 다른 작업을 동시에 진행할 수가 없다는 것을 뜻한다. 일반적으로 자바스크립트를 사용하면 블록킹 방식으로 진행된다는 것을 알 수 있다.

**결국 프로그래밍에서의 동기의 뜻은 동시에 발생해야하는 조건이라고 볼 수 있다. 자바스크립트에서는 코드를 위에서부터 아래로 순차적으로 실행이 되며, 상위코드가 완료가 되지 않는다면 하위코드 역시 실행이 되지 않는 것과 같다. 즉, 동기는 모든 코드가 순서를 가지고 실행되는 것이라고 생각한다.**

### 비동기 - 논블로킹 방식

비동기 방식은 현재 작업의 응답과 다음 작업의 요청이 동시에 진행되지 않아도 되는 것으로 응답에 관계없이 바로 다음 동작이 실행되는 것을 말한다. 특정 작업을 시작(리퀘스트 보내기)하고 완벽하게 다 처리(리스폰스를 받아서 처리)하기 전에 실행 흐름이 바로 다음 코드로 넘어가고, 나중에 콜백이 실행되는 것을 ‘비동기 실행’이라 할 수 있다.

그렇다면 ‘비동기 실행’이라는 건 왜 존재하는 걸까?

그건 바로 보통 ‘비동기 실행’이 ‘동기 실행’에 비해, 동일한 작업을 더 빠른 시간 내에 처리 할 수 있기 때문이다.

논블록킹 방식은 직접 제어할 수 없는 대상의 작업처리 여부와 상관없이 자신의 작업을 진행할 수 있는 것으로, 상위 프로세스는 하위 프로세스의 작업 완료 여부 또한 신경쓰지 않는다.

보통 자바스크립트로 웹 통신을 하려면 비동기 실행으로 진행되는데, 이러한 이유는 웹 페이지가 로딩되거나 어떠한 이벤트의 소요시간이 길다면 화면이 나타나지 않거나 의도하지 않은 동작이 일어나므로 비동기방식을 통해 페이지가 로딩 중이라는 것을 사용자가 알 수 있도록 해야만 한다.

# **동기(Synchronous)와 비동기(asynchronous) 정리**

### **동기(Synchronous)**

1. 모든 코드가 순서를 가지고 실행되는 것으로 호출된 함수의 리턴하는 시간과 결과를 반환하는 시간이 일치
2. 작업이 순차적으로 진행되는 것이 보장
3. 블록킹 방식이기 때문에 어떠한 작업이 진행 중일 때는 다른 작업을 동시에 진행할 수가 없다는 것

### **비동기(asynchronous)**

1. 응답에 관계없이 바로 다음 동작이 실행되는 것으로 호출된 함수의 리턴하는 시간과 결과를 반환하는 시간이 불일치
2. 비동기 실행에서는 코드가 꼭 등장하는 순서대로 실행되는 것이 아니므로, 코드를 해석할 때 주의가 필요
3. ‘비동기 실행’이 ‘동기 실행’에 비해, 동일한 작업을 더 빠른 시간 내에 처리