자바스크립트 = 스택이1개다(싱글 스레드방식)

1초에 60프레임
스택은 위로만쌓을수있는 박스(후입선출(LIFO, Last-In-First-Out)) 구조

큐는 가로로 빨대같은 구조(선입선출)


- 실행 컨텍스트(execution context)

자바스크립트 코드가 실행이 되는 환경 정도로 이해하면 된다.
자바스크립트에서 실행 컨텍스트가 생성되는 조건은 다음과 같다.

- 함수 실행
- eval() 실행
- 전역 실행


- 디바운스
짧은 시간 간격으로 이벤트가 연속해서 발생하면 이벤트 핸들러를 호출하지 않다가 일정 시간이 경과한 이후에 이벤트 핸들러가 한 번만 호출되도록 한다.
즉, 디바운스는 짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 마지막에 한 번만 이벤트 핸들러가 호출되도록 한다.
디바운스는 resize 이벤트 처리나 input 요소에 입력된 값으로 AJAX 요청하는 입력 필드 자동완성 UI 구현, 버튼 중복 클릭 방지 처리 등에 유용하게 사용된다.


- 쓰로틀 Throttle

짧은 시간 간격으로 이벤트가 연속해서 발생하더라도 일정 시간 간격으로 이벤트 핸들러가 최대 한 번만 호출되도록 한다.
▶ 함수 호출 주기 동안 함수가 한 번만 호출된다.
즉, 스로틀은 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 만든다.
스로틀은 scroll 이벤트 처리나 무한 스크롤(infinite scrolling) UI 구현 등에 유용하게 사용된다.
실무에서는 Underscore 또는 Lodash의 throttle 함수를 사용하는 것을 권장한다.

*Lodash는 자바스크립트의 라이브러리다.
여러가지 기능이있지만 배열이나 객체의 정렬 (sordby, orderby)이나 디바운스, 스로틀기능을 주로 많이씀


 - 브라우저에 url를 치면 일어나는일

DNS가 루트도메인부터 거꾸로 해석해서 들어간다.
웹브라우저는 url주소를 입력받으면 dns서버에게 해당 url의 IP주소를 물어보고 dns는 해당url의 IP주소와 랜덤한숫자를 같이준다
클라이언트는 DNS서버에게 받은 IP주소로 가서 서버에게 랜덤한숫자에 +1된 값을 받고 클라이언트는 이 번호에 +1를 더해서 서버에게 다시준다
이 과정을 3way handshake이다
이때 써버에게 자료를 요청하는걸 HTTP REQUEST라고하고
서버가 클라이언트에게 응답하는걸 HTTP RESPONSE라고 한다
브라우저는 서버에게 받은 자료를 사용자가 이해할수있게 해석해서 화면에 보여준다.


- 자바스크립트에서 This란?


핵심 = 함수를 호출하는 방법에 의해 결정된다.
어떻게 호출되었는지 개의치않고 설정할수있는 bind 메소드가 있다.
call, apply, bind 종류가 있다

1. 자바스크립트 엔진에 의해 암묵적으로 생성됩니다.
2. 따라서 어디서든 참조할 수 있습니다.
3. 함수를 호출하면 arguments 객체와 this가 암묵적으로 전달됩니다.
4. this도 지역변수처럼 사용할 수 있습니다.
5. this가 가리키는 값, this 바인딩은 함수 호출 방식에 따라 동적으로 결정됩니다.

 - 호이스팅이란?

-var 키워드로 선언되거나 초기화된 변수, 함수선언은 현재 스코프의 최상위까지 끌어 올려집니다. 이것을 호이스팅이라고 부릅니다
함수 선언은 함수몸체가 호이스팅되는 반면, 변수 선언 형태로 작성된 함수 표현식은 변수 선언만 호이스팅됩니다.


호이스팅이 되는 이유?
선언문을 해당 스코프의 맨 위로 옮겨서 먼저 파싱하여 동작을 더 효율적이게 하기위함이다.


var 키워드로 선언한 변수가 가진 문제점은 아래와 같습니다.
1. 변수 중복 선언 `허용`
2. 함수 레벨 스코프, `function() {}`,
3. 변수 호이스팅으로 `변수 선언문 이전에 참조가 가능`하며, 할당문 이전에 참조 시 undefined를 반환
4. `전역 변수`, `전역 함수`, 선언하지 않은 변수에 값을 할당한 `암묵적 전역`은 전역 객체 window의 프로퍼티에 할당

이런 이유로 가독성, 개발자의 의도가 흐려지게 되었고 결국 let과 const가 등장하게 됩니다.


### 📣 let
> ES6에 추가된 블록 레벨 스코프의 재할당이 가능한 키워드입니다.

let 키워드로 선언한 변수는 var 키워드를 대체할 수 있으며, 아래와 같은 특징을 갖습니다.
1. 변수 중복 선언 `금지`, 중복 선언 시 문법 에러(SyntaxError) 발생
2. `function() {}, if 문, for 문, while 문, try/catch 문 등` 함수레벨스코프이면서 블록레벨 스코프다.
3. 변수 호이스팅이 `발생하지 않는` 것처럼 동작
4. 전역 객체 window의 프로퍼티가 아니며 let 전역 변수는 `보이지 않는 개념적 블록(전역 렉시컬 환경의 선언적 환경 레코드)` 내에 존재

var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 `선언 단계`와 `초기화 단계`가 동시에 진행되는 반면 let, const 키워드로 선언한 변수는 `선언 단계`와 `초기화 단계`가 분리되어 진행됩니다.

### 📣 const
> ES6에 추가된 블록 레벨 스코프의 재할당 불가능한 상수(constant)를 선언하는 키워드입니다.

const 키워드는 기본적으로 let과 동일하게 동작합니다. 다른 점은 `반드시 선언과 동시에 초기화`해야 한다는 것이에요.


- 스코프 체인이란?

함수기준으로 자기자신안에 변수를 찾고 없으면 그 위에 가까운 함수안에서 찾으러 올라간다.
이렇게 범위를 넓히면서 찾아가는 관계를 스코프 체인이라고한다.



- CORS (Cross Origin Resource Sharing) 란?

일단 SOP(Same Origin Policy)를 알아야 CORS를 설명가능 SOP란?
어떤 Origin(출처)에서 불러온 문서나 스크립트가 다른 Origin과 상호작용하는 것을 제한하는 중요한 보안 방식. 즉, 동일한 Origin으로만 요청을 보낼 수 있게 함

물론 외부 API를 사용하거나 서버-클라이언트 통신 시 불편함이 존재하는데, 이를 해결하기 위해 등장한 정책중 하나가 CORS(Cross-Origin Resource Sharing) 정책입니다.
SOP는 한국말로 '동일 출처 정책'이라고 부르며, CORS는 '교차 출처 자원 공유'라고 부른다
CORS(Cross Origin Resource Sharing)는 다른 Origin으로 요청을 보내기 위해 지켜야 하는 정책으로, 원래대로라면 SOP에 의해 막히게 될 요청을 풀어주는 정책이다.


하지만 동작 원리를 조금 더 깊게 들어가면 CORS 요청은 다음과 같이 세 가지 유형으로 나눠서 생각해볼 수 있다.

1. 단순 요청 (Simple Request) -> 
2. 프리플라이트 요청 (Preflight Request) -> 단순요청이 아닐경우
3. 인증 정보를 포함한 요청 (Credentialed Request) -> 


- useMemo, useCallback, React.memo

리액트는 특정 컴포넌트가 리렌더링 되면 그 컴포넌트의 모든 하위컴포넌트도 리렌더링이 된다. 
그 때 불필요하게 리렌더링 되는 상황이 발생하는데 그것을 막기 위해 JS의 메모이제이션 기능을 이용해서 만든 기능이 useMemo, useCallback + React.memo이다.



Memoization 기법
- 이미 계산 해 본 연산결과를 기억해 두었다가 동일한 계산을 시키면 다시 계산하지않고 기억해두었던 데이터를 반환시키게 하는 방법
즉, 필요없는 리랜더링을 막아 성능최적화를 할수있다.



- Key는 왜쓰는지?


- Key는 엘리먼트 배열을 작성할 때 반드시 포함해야 하는 특별한 문자열 Attribute입니다. Key 프로퍼티는 리액트가 변경, 추가 또는 제거된 항목을 식별하도록 돕습니다.
가상돔과 리얼돔의 비교를 할때 필요함.

대부분의 경우 데이터의 ID를 키로 사용합니다. (id값을 value마다 각자 다른 값을 가지고 있을때) 없다면 index를 key로 주로 사용한다 
구성된 배열(또는 목록)의 순서가 변경될 수 있는 경우 Key에 index를 사용하지 않는 것이 좋다


- 프롭스 드릴링이란?

Prop Drilling 은 props를 오로지 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트들을 거치면서 React Component 트리의 한 부분에서 
다른 부분으로 데이터를 전달하는 과정입니다.
prop 전달이 3~5개 정도의 컴포넌트라면 Prop Drilling 는 문제가 되지 않습니다. 
하지만 prop 전달이 10개, 15개 같이 더 많은 과정을 거치게 된다면 코드를 읽을 때 해당 prop을 추적하기 힘들어집니다.
그렇기 때문에 유지보수도 더욱 어려워집니다.

- Redux 란?

Redux(리덕스)란 JavaScript(자바스트립트) 상태관리 라이브러리이다.
//Redux(리덕스)의 본질은 Node.js 모듈이다. 
단방향이기때문에 예측성이 쉬워서 유지보수가 쉽다.
Flux 구조이다

❗️Redux의 장점
상태를 예측 가능하게 만든다. (순수함수를 사용하기 때문)
유지보수 (복잡한 상태 관리와 비교)
디버깅에 유리 (action과 state log 기록 시) → redux dev tool (크롬 확장)
테스트를 붙이기 용의 (순수함수를 사용하기 때문)

❗️Store, Action, Reducer의 의미와 특징

🧺 Store (스토어)
Store(스토어)는 상태가 관리되는 오직 하나의 공간이다.
컴포넌트와는 별개로 스토어라는 공간이 있어서 그 스토어 안에 앱에서 필요한 상태를 담는다.
컴포넌트에서 상태 정보가 필요할 때 스토어에 접근한다.
📃 Action (액션)
Action(액션)은 앱에서 스토어에 운반할 데이터를 말한다. (주문서)
Action(액션)은 자바스크립트 객체 형식으로 되어있다.
🎉 Reducer (리듀서)
Action(액션)을 Store(스토어)에 바로 전달하는 것이 아니다.
Action(액션)을 Reducer(리듀서)에 전달해야한다.
Reducer(리듀서)가 주문을 보고 Store(스토어)의 상태를 업데이트하는 것이다.
Action(액션)을 Reducer(리듀서)에 전달하기 위해서는 dispatch() 메소드를 사용해야한다.

Action(액션) 객체가 dispatch() 메소드에 전달된다.
dispatch(액션)를 통해 Reducer를 호출한다.
Reducer는 새로운 Store 를 생성한다.



- 리액트 라이프 사이클

크게 세가지 유형으로 나눌 수 있는데 생성 될때, 업데이트 할 때, 제거할 때이다. 이를 리액트에서는 마운트, 업데이트, 언마운트라고 한다

여기서 마운트는 DOM이 생성되고 웹 브라우저 상에서 나타나는 것을 뜻하고, 반대로 언마운트는 DOM에서 제거되는 것을 뜻한다.
주의하여 볼 것은 업데이트 부분인데, 업데이트는 다음과 같은 4가지 상황에서 발생한다.

1. props가 바뀔 때
2. state가 바뀔 때
3. 부모 컴포넌트가 리렌더링 될 때
4. this.forceUpdate로 강제로 렌더링을 트리거할 때

라이프사이클은 총 9개가 존재하는데

1. constructor => 이 메서드에서는 초기 state를 정할 수 있다.
2. getDerivedStateFromProps => 이 메서드는 리액트 16.3버전 이후에 생긴 메서드이다
props로 받아 온 값을 state에 동기화시키는 용도로 사용하며, 컴포넌트가 마운트될 때와 업데이트 될 때 호출된다.
*중요 3. shouldComponentUpdate => 이 메서드는 props나 state를 변경했을 때, 리렌더링을 할지 말지 결정하는 메서드이다. 이 메서드에서는 반드시 true나 false를 반환해야한다. 이 메서드는 오직 성능 최적화만을 위한 것이며 렌더링 목적을 방지하는 목적으로 사용하게된다면 버그로 이어질 수 있다.
**중요 4. render => 이는 가장 기초적인 메서드이기도하고 가장 중요한 메서드이기도 하다. 컴포넌트를 렌더링할 때 필요한 메서드로 유일한 필수 메서드이기도 하다. 함수형 컴포넌트에서는 render를 안쓰고 컴포넌트를 렌더링할 수 있다.
5. getSnapshotBeforeUpdate => 이 메서드는 render에서 만들어진 결과가 브라우저에 실제로 반영되기 직전에 호출된다
6. componentDidMount => 이 메서드는 컴포넌트를 만들고 첫 렌더링을 마친 후 실행한다. 함수형 Hooks 에서는 useEffect를 활용하여 다음의 기능을 구현할 수 있다.
7. ComponentDidUpdate =>이것은 리렌더링을 완료한 후 실행한다. 업데이트가 끝난 직후이므로, DOM관련 처리를 해도 무방하다.
8. componentWillUnmount => 이 메서드는 컴포넌트를 DOM에서 제거할 때 실행한다. 
9. componentDidCatch




