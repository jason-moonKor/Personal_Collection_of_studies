자바스크립트에서 This 란 뭔가요?
호이스팅이 일어나는 이유?
스코프체인이란?

브라우저 렌더링에대해 자세히 면접때 말하듯이 연습

-------------------------

https://blog.naver.com/choirj91/222347163902

=> 노드에서 this랑 js에서의 this랑 다름

1. 자바스크립트에서 This란 무엇?

> 자기 참조 변수(self-referencing variable)로 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리킵니다.

1. 자바스크립트 엔진에 의해 암묵적으로 생성됩니다.
2. 따라서 어디서든 참조할 수 있습니다.
3. 함수를 호출하면 arguments 객체와 this가 암묵적으로 전달됩니다.
4. this도 지역변수처럼 사용할 수 있습니다.
5. this가 가리키는 값, this 바인딩은 함수 호출 방식에 따라 동적으로 결정됩니다.



2. 호이스팅이란?

호이스팅이 되는 이유?
- 그러나 선언문만 호이스팅되며 할당된 내용은 호이스팅되지않는다.
선언문은 실제로 자리가 이동되진 않는다. 자바스크립트 엔진은 컴파일 중에 선언문을 파싱하고 선언문과 해당 스코프를 인식합니다. 
선언문을 해당 스코프의 맨 위로 옮겨서 먼저 파싱하여 동작을 더 효율적이게 하기위함이다.

-var 키워드로 선언되거나 초기화된 변수, 함수선언은 현재 스코프의 최상위까지 끌어 올려집니다. 이것을 호이스팅이라고 부릅니다
함수 선언은 함수몸체가 호이스팅되는 반면, 변수 선언 형태로 작성된 함수 표현식은 변수 선언만 호이스팅됩니다.

## 💬 `function foo() {}`와 `var foo = function() {}` 사이에서 foo 사용의 차이에 대해 설명하세요.
전자는 함수 선언인 반면, 후자는 함수 표현식입니다. 주요한 차이점은 함수 선언은 함수바디가 호이스트되지만, 
함수 표현식의 바디는 호이스트되지 않습니다(변수와 동일한 호이스팅 동작을 가짐). 
호이스팅에 대한 자세한 설명은 질문 위의 호이스팅을 참조하십시오. 함수 표현식을 정의하기 전에 호출하려고 하면 
`Uncaught TypeError : XXX is not function` 에러가 발생합니다.

## 💬 let, var, const를 사용하여 생성된 변수들의 차이점은 무엇인가요?
var 키워드로 선언한 변수가 가진 문제점은 아래와 같습니다.
1. 변수 중복 선언 `허용`
2. 함수 레벨 스코프, `function() {}`
3. 변수 호이스팅으로 `변수 선언문 이전에 참조가 가능`하며, 할당문 이전에 참조 시 undefined를 반환
4. `전역 변수`, `전역 함수`, 선언하지 않은 변수에 값을 할당한 `암묵적 전역`은 전역 객체 window의 프로퍼티에 할당

이런 이유로 가독성, 개발자의 의도가 흐려지게 되었고 결국 let과 const가 등장하게 됩니다.


## 💬 let, var, const를 사용하여 생성된 변수들의 차이점은 무엇인가요?
var 키워드로 선언한 변수가 가진 문제점은 아래와 같습니다.
1. 변수 중복 선언 `허용`
2. 함수 레벨 스코프, `function() {}`
3. 변수 호이스팅으로 `변수 선언문 이전에 참조가 가능`하며, 할당문 이전에 참조 시 undefined를 반환
4. `전역 변수`, `전역 함수`, 선언하지 않은 변수에 값을 할당한 `암묵적 전역`은 전역 객체 window의 프로퍼티에 할당

이런 이유로 가독성, 개발자의 의도가 흐려지게 되었고 결국 let과 const가 등장하게 됩니다.


### 📣 const
> ES6에 추가된 블록 레벨 스코프의 재할당 불가능한 상수(constant)를 선언하는 키워드입니다.

const 키워드는 기본적으로 let과 동일하게 동작합니다. 다른 점은 `반드시 선언과 동시에 초기화`해야 한다는 것이에요.




3. 스코프 체인이란?

자바스크립트의 함수를 실행하면서 어떤 속성(변수, 객체 등)에 접근해야 할 때 해당 속성을 효율적으로 탐색하도록 속성을 일정한 객체 단위로 분류하고 각 객체에 접근하기 위한 객체의 참조를 특정한 공간에 저장해 둡니다. 이 공간이 바로 스코프 체인입니다.







